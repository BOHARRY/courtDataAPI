# 案由搜尋 - 門檻調整報告

## 🐛 問題診斷

### 問題 1: Layer 1 返回過多結果

**現象**:
```
[CaseDescriptionSearch] ES 返回總數: 9891
[CaseDescriptionSearch] Layer 1 完成: 200 筆候選
```

**原因**:
- `minimum_should_match: 1` 太寬鬆
- 10 個關鍵詞中只要命中 1 個就算
- 「承租人」、「出租人」、「租賃契約」等詞在民事判決中極為常見
- 結果：幾乎所有民事判決（9,891 / 10,515 = 94%）都被匹配

**修正**:
```javascript
// 修正前
minimum_should_match: 1  // ❌ 只要命中 1 個詞

// 修正後
const minimumMatch = Math.max(2, Math.ceil(totalClauses * 0.3));  // ✅ 至少 30% 或 2 個詞
```

**預期效果**:
- 10 個詞 → 至少命中 3 個詞
- 應該能將結果從 9,891 筆降低到 1,000-2,000 筆左右

---

### 問題 2: Layer 2 門檻過高

**現象**:
```
[CaseDescriptionSearch] 候選 0: similarity = 0.6266
[CaseDescriptionSearch] 候選 1: similarity = 0.5415
[CaseDescriptionSearch] 候選 2: similarity = 0.5778
[CaseDescriptionSearch] 相似度範圍: 0.3921 ~ 0.6587, 平均: 0.5564
[CaseDescriptionSearch] Layer 2 完成: 0 筆候選  ❌
```

**原因**:
- 門檻設定: **0.70**
- 實際最高相似度: **0.6587**
- 所有 200 筆候選都被過濾掉了！

**分析**:
- 平均相似度: 0.5564
- 最高相似度: 0.6587
- 門檻 0.70 過高，導致零結果

**修正**:
```javascript
// 修正前
threshold = 0.70  // ❌ 過高

// 修正後
threshold = 0.55  // ✅ 略高於平均值，能保留高品質結果
```

**預期效果**:
- 門檻 0.55 應該能保留約 50-60% 的候選（100-120 筆）
- 這些候選的相似度都在平均值以上

---

## ✅ 修正方案

### 修正 1: 動態調整 minimum_should_match

**位置**: `services/caseDescriptionSearchService.js` Line 144-178

**修正內容**:
```javascript
// 動態計算 minimum_should_match
// 策略：至少命中 30% 的詞彙，但最少 2 個，最多不超過總數
const totalClauses = shouldClauses.length;
const minimumMatch = Math.max(2, Math.min(totalClauses, Math.ceil(totalClauses * 0.3)));
console.log(`[CaseDescriptionSearch] minimum_should_match: ${minimumMatch} (總詞彙: ${totalClauses})`);
```

**效果**:
| 總詞彙數 | minimum_should_match | 說明 |
|---------|---------------------|------|
| 1-6 個 | 2 | 最少 2 個 |
| 7-9 個 | 3 | 30% 向上取整 |
| 10 個 | 3 | 30% = 3 個 |
| 15 個 | 5 | 30% 向上取整 |

### 修正 2: 降低 Layer 2 語義過濾門檻

**位置**: `services/caseDescriptionSearchService.js` Line 225 & 573

**修正內容**:
```javascript
// 函數定義
function semanticFilter(candidates, queryVector, threshold = 0.55) {
    // ...
}

// 調用
const layer2Candidates = semanticFilter(layer1Candidates, queryVector, 0.55);
```

**門檻選擇理由**:
- 實測平均相似度: 0.5564
- 實測最高相似度: 0.6587
- 選擇 0.55 略低於平均值，確保能保留足夠的高品質候選
- 如果 0.55 仍然過濾太多，可以進一步降低到 0.50

---

## 🧪 測試驗證

### 預期 Log 輸出

**Layer 1**:
```
[CaseDescriptionSearch] 構建的 should clauses 數量: 10
[CaseDescriptionSearch] minimum_should_match: 3 (總詞彙: 10)
[CaseDescriptionSearch] ES 返回總數: 1500  ✅ 從 9891 降低
[CaseDescriptionSearch] Layer 1 完成: 200 筆候選
```

**Layer 2**:
```
[CaseDescriptionSearch] Layer 2: 語義過濾（門檻: 0.55）...
[CaseDescriptionSearch] 相似度範圍: 0.3921 ~ 0.6587, 平均: 0.5564
[CaseDescriptionSearch] Layer 2 完成: 100 筆候選  ✅ 不再是 0
```

**Layer 3**:
```
[CaseDescriptionSearch] 核心法條: ['民法第767條', '民法第184條', ...]
[CaseDescriptionSearch] Layer 3 完成: 25 筆候選  ✅
```

**Layer 4**:
```
[CaseDescriptionSearch] Layer 4 完成: 15 筆有效候選  ✅
```

---

## 📊 門檻調整策略

### Layer 2 門檻調整建議

根據實測數據，建議的門檻範圍：

| 門檻 | 預期保留比例 | 適用場景 |
|-----|------------|---------|
| 0.50 | ~70% | 寬鬆，確保召回率 |
| 0.55 | ~50% | **推薦**，平衡精確度與召回率 |
| 0.60 | ~30% | 嚴格，提高精確度 |
| 0.65 | ~10% | 非常嚴格，可能過濾太多 |
| 0.70 | ~0% | ❌ 過高，實測無結果 |

### 動態門檻策略（未來優化）

可以考慮根據候選數量動態調整門檻：

```javascript
// 如果候選太多，提高門檻
// 如果候選太少，降低門檻
function adaptiveThreshold(candidates, targetCount = 60) {
    const similarities = candidates.map(c => 
        cosineSimilarity(queryVector, c.summary_ai_vector)
    ).sort((a, b) => b - a);
    
    // 取第 targetCount 名的相似度作為門檻
    return similarities[Math.min(targetCount, similarities.length - 1)];
}
```

---

## 🔍 進一步優化建議

### 1. Layer 1 優化

**問題**: 即使調整到 `minimum_should_match: 3`，可能還是會返回太多結果。

**建議**:
- 為不同類型的詞彙設置不同的權重
- 法條詞彙（statute_terms）權重更高
- 通用詞彙（如「承租人」）權重較低

```javascript
// 優化後的 boost 策略
shouldClauses.push({
    multi_match: {
        query: term,
        fields: searchFields,
        type: 'best_fields',
        boost: getBoost(termType, term)  // 動態 boost
    }
});

function getBoost(termType, term) {
    if (termType === 'statute_terms') return 2.0;  // 法條最高
    if (termType === 'legal_action_terms') return 1.5;  // 法律行為次之
    if (isCommonTerm(term)) return 0.5;  // 常見詞降低
    return 1.0;  // 預設
}
```

### 2. Layer 2 優化

**建議**: 使用 Top-K 策略而非固定門檻

```javascript
// 不使用固定門檻，而是取 Top 60 名
function semanticFilterTopK(candidates, queryVector, k = 60) {
    const scored = candidates
        .map(candidate => ({
            ...candidate,
            semantic_score: cosineSimilarity(queryVector, candidate.summary_ai_vector)
        }))
        .sort((a, b) => b.semantic_score - a.semantic_score)
        .slice(0, k);  // 取前 k 名
    
    return scored;
}
```

### 3. Layer 3 優化

**建議**: 如果核心法條為空，使用備用策略

```javascript
// 如果沒有核心法條（出現次數 >= 3），降低門檻到 >= 2
if (coreStatutes.length === 0) {
    coreStatutes = getStatutesWithMinCount(layer2Candidates, 2);
}
```

---

## 📝 已修改的檔案

1. **`services/caseDescriptionSearchService.js`**
   - Line 144-178: 動態調整 `minimum_should_match`
   - Line 225: 修改 `semanticFilter` 預設門檻 0.70 → 0.55
   - Line 573: 修改調用時的門檻 0.70 → 0.55

---

## 🚀 下一步

1. **重啟後端服務**
   ```bash
   cd d:\court_data\courtDataAPI
   node index.js
   ```

2. **前端測試**
   - 輸入相同的案情描述
   - 觀察新的 log 輸出

3. **驗證結果**
   - Layer 1 應該返回較少結果（1,000-2,000 筆）
   - Layer 2 應該保留 50-100 筆候選
   - Layer 3 應該有核心法條
   - Layer 4 應該有最終結果

4. **微調門檻**
   - 如果 Layer 2 仍然 0 筆 → 降低到 0.50
   - 如果 Layer 2 太多筆（>150） → 提高到 0.60
   - 如果 Layer 1 仍然太多 → 提高 minimum_should_match 到 40%

---

## ✅ 總結

**已完成的修正**:
- ✅ 動態調整 `minimum_should_match`（1 → 30% 或至少 2 個）
- ✅ 降低 Layer 2 門檻（0.70 → 0.55）
- ✅ 添加詳細的 debug log

**預期效果**:
- Layer 1: 9,891 筆 → 1,500 筆左右
- Layer 2: 0 筆 → 100 筆左右
- Layer 3: 0 筆 → 25 筆左右
- Layer 4: 0 筆 → 15 筆左右

準備好測試了！🎉

